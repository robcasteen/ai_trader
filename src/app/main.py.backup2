import logging
import json
import os
from pathlib import Path
from fastapi import FastAPI
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
from datetime import datetime

# --- Configure logging early so our INFO lines always show
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
)

# --- Dashboard (UI) ---
from app.dashboard import router as dashboard_router

# --- Trading logic ---
from app.logic.sentiment import SentimentSignal
from app.logic.paper_trader import PaperTrader
from app.logic.notifier import Notifier
from app.logic.symbol_scanner import get_top_symbols
from app.news_fetcher import get_unseen_headlines, mark_as_seen
from app.client.kraken import KrakenClient
from app.config import get_current_config

# --- Core bot components ---
client = KrakenClient()
kraken = KrakenClient()
signal_model = SentimentSignal()
trader = PaperTrader()
notifier = Notifier()

# --- State tracking ---
PROJECT_ROOT = Path(__file__).resolve().parents[1]  # /src
LOGS_DIR = PROJECT_ROOT / "logs"
LOGS_DIR.mkdir(parents=True, exist_ok=True)
STATUS_FILE = LOGS_DIR / "bot_status.json"

# Initialize in-memory last status (diagnostic only; never returned by /status unless /run-now is called)
last_status = {"time": None, "message": "Bot has not run yet.", "next_run": "Unknown"}

# --- FastAPI app ---
app = FastAPI(title="Trading Bot Dashboard")

# Mount static files
from fastapi.staticfiles import StaticFiles

PROJECT_ROOT_STATIC = Path(__file__).resolve().parents[1]  # /src
app.mount(
    "/static", StaticFiles(directory=str(PROJECT_ROOT_STATIC / "static")), name="static"
)

# Mount the dashboard UI routes
app.include_router(dashboard_router)


def save_status_to_file(status: dict):
    """Persist bot status to logs/bot_status.json and keep memory in sync."""
    global last_status
    last_status = status
    try:
        with open(STATUS_FILE, "w") as f:
            json.dump(status, f, indent=2)
        logging.info(f"[Status] Updated bot_status.json: {status}")
    except Exception as e:
        logging.error(f"[Status] Failed to write status file: {e}")


def normalize_symbol(sym: str) -> str:
    """Ensure 'BTCUSD' -> 'BTC/USD' for price/trade consistency."""
    if "/" in sym:
        return sym
    if len(sym) > 3:
        base, quote = sym[:-3], sym[-3:]
        return f"{base}/{quote}"
    return sym


"""
Updated run_trade_cycle to use StrategyManager with multiple strategies.

Replace the run_trade_cycle function in src/app/main.py with this version.
"""


def run_trade_cycle():
    """Run one trade evaluation cycle with multi-strategy analysis."""
    start_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    logging.info(f"[TradeCycle] === Starting cycle at {start_time} ===")

    # Initialize strategy manager with correct logs directory
    from app.strategies.strategy_manager import StrategyManager
    from pathlib import Path

    # Get logs directory
    PROJECT_ROOT = Path(__file__).resolve().parents[1]  # ADD THIS
    LOGS_DIR = PROJECT_ROOT / "logs"  # ADD THIS

    # Configure strategy manager
    strategy_config = {
        "use_technical": True,
        "use_volume": True,
        "min_confidence": 0.5,
        "aggregation_method": "weighted_vote",
        "logs_dir": str(LOGS_DIR),  # ADD THIS
    }

    strategy_manager = StrategyManager(config=strategy_config)

    # Fetch scanner symbols and unseen headlines
    symbols = get_top_symbols(limit=10)
    headlines_by_symbol = get_unseen_headlines()

    logging.info(f"[Scanner] Top {len(symbols)} symbols: {symbols}")
    logging.info(
        f"[News] Retrieved {len(headlines_by_symbol)} symbol groups with unseen headlines"
    )

    # Combine symbols from scanner and news
    all_symbols = set(symbols)
    all_symbols.update(headlines_by_symbol.keys())

    if not all_symbols:
        msg = "No actionable headlines or symbols."
        logging.info(f"[TradeCycle] {msg}")
        save_status_to_file(
            {"time": start_time, "message": msg, "next_run": get_next_run_time()}
        )
        logging.info(
            f"[TradeCycle] === Completed cycle at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ==="
        )
        return

    # Process each symbol
    for symbol in all_symbols:
        logging.info(f"[{symbol}] Checking...")

        try:
            # Get current price
            price = client.get_price(symbol)
            logging.info(f"[{symbol}] Current price: {price}")

            # Get current balance
            balance = client.get_balance()
            logging.info(f"[{symbol}] Current USD balance: {balance}")

            # Prepare context for strategies
            context = {
                "headlines": headlines_by_symbol.get(symbol, []),
                "price": price,
                "symbol": symbol,
            }

            # Add price history if available (for technical analysis)
            try:
                # You can implement price history fetching here
                # For now, we'll use single price point
                context["price_history"] = [price]
                context["volume_history"] = []
            except:
                context["price_history"] = [price]
                context["volume_history"] = []

            # Get aggregated signal from all strategies
            signal, confidence, reason = strategy_manager.get_signal(symbol, context)

            logging.info(f"[{symbol}] Signal: {signal} | Reason: {reason}")

            # Execute trade based on signal
            result = trader.execute_trade(
                symbol=symbol,
                action=signal,
                price=price,
                balance=balance,  # ADD THIS LINE
                reason=reason,
            )

            logging.info(f"[{symbol}] Trade result: {result}")

            # Send notification
            notifier.send(result)

            logging.info(f"[{symbol}] Notified result.")

            # Mark headlines as seen
            if symbol in headlines_by_symbol:
                mark_as_seen(symbol, headlines_by_symbol[symbol])
                logging.info(
                    f"[{symbol}] Marked {len(headlines_by_symbol[symbol])} headlines as seen."
                )

        except Exception as e:
            logging.error(f"[{symbol}] Error processing: {e}")
            continue

    # Update status
    end_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    save_status_to_file(
        {
            "time": end_time,
            "message": f"Processed {len(all_symbols)} symbols with multi-strategy analysis",
            "next_run": get_next_run_time(),
        }
    )

    logging.info(f"[TradeCycle] === Completed cycle at {end_time} ===")


def get_next_run_time():
    """Calculate next scheduled run time."""
    from datetime import datetime, timedelta

    next_run = datetime.now() + timedelta(minutes=5)
    return next_run.strftime("%Y-%m-%d %H:%M:%S")


# --- Scheduler setup ---
scheduler = BackgroundScheduler()


@app.on_event("startup")
def start_scheduler():
    logging.info("[Startup] FastAPI app is launching...")

    # If we're under pytest, don't start the scheduler (prevents background writes during tests)
    if os.environ.get("PYTEST_CURRENT_TEST"):
        logging.info("[Startup] Detected pytest environment; scheduler will NOT start.")
        logging.info(
            "[Startup] Application startup complete. Ready to accept requests."
        )
        return

    if not scheduler.running:
        trigger = IntervalTrigger(minutes=5)
        job = scheduler.add_job(
            run_trade_cycle, trigger, id="trade_cycle", replace_existing=True
        )
        scheduler.start()
        logging.info(
            "[Startup] Scheduler started. Trade cycle scheduled every 5 minutes."
        )
        logging.info(f"[Startup] Next scheduled run at: {job.next_run_time}")

    # IMPORTANT: Do NOT run an immediate cycle here.
    logging.info("[Startup] Application startup complete. Ready to accept requests.")


@app.on_event("shutdown")
def shutdown_scheduler():
    if scheduler.running:
        scheduler.shutdown()
        logging.info("[Shutdown] Scheduler shutdown complete.")


# --- Manual trigger endpoint ---
@app.get("/run-now")
def run_now():
    logging.info("[Manual] Trade cycle triggered via /run-now endpoint")
    run_trade_cycle()

    job = scheduler.get_job("trade_cycle")
    next_run = (
        job.next_run_time.strftime("%Y-%m-%d %H:%M:%S")
        if job and job.next_run_time
        else "Unknown"
    )

    return {
        "status": "ok",
        "message": "Trade cycle executed",
        "last_status": last_status,
        "next_run": next_run,  # keep top-level next_run for callers/tests
    }


# --- Bot status endpoint ---
@app.get("/status")
def get_status():
    """Expose bot's last run status for the dashboard.

    Test-friendly behavior:
    - Always attempt to read the *current* STATUS_FILE (patched path during tests).
    - If reading fails, return a deterministic payload.
    """
    try:
        with open(STATUS_FILE, "r") as f:
            status = json.load(f)
        # Always return the file contents; never fall back to in-memory status here
        return {"last_status": status}
    except Exception as e:
        logging.error(f"[Status] Failed to read status file {STATUS_FILE}: {e}")

    # File missing or unreadable: return deterministic payload (no in-memory fallback)
    return {
        "last_status": {
            "time": None,
            "message": "No status file found",
            "next_run": "Unknown",
        }
    }
